{
  "slug": "js-output",
  "questions": [
    {
      "id": "out-01",
      "q": "What is the output?",
      "a": "```javascript\nfunction sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = 'Lydia';\n  let age = 21;\n}\n\nsayHi();\n```\n\n**Output:**\n```text\nundefined\nReferenceError\n```\n\n**Explanation:**\n*   **`name`** is declared with `var`, so it is **hoisted** to the top of the function with the value `undefined`. That's why the first log prints `undefined`.\n*   **`age`** is declared with `let`, so it is also hoisted but remains in the **Temporal Dead Zone (TDZ)** until the declaration line is reached. Accessing it before declaration throws a `ReferenceError`.",
      "difficulty": "Medium",
      "tags": ["hoisting", "scope"]
    },
    {
      "id": "out-02",
      "q": "What is the output?",
      "a": "```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n```\n\n**Output:**\n```text\n3 3 3\n0 1 2\n```\n\n**Explanation:**\n*   **Loop 1 (`var`)**: `var` has **function scope** (or global). By the time the `setTimeout` callbacks run, the loop has finished and `i` is `3`. All callbacks refer to the *same* variable `i`.\n*   **Loop 2 (`let`)**: `let` has **block scope**. In each iteration, a *new* variable `i` is created with the current value. Each callback refers to its own specific `i`.",
      "difficulty": "Medium",
      "tags": ["loops", "closures", "async"]
    },
    {
      "id": "out-03",
      "q": "What is the output?",
      "a": "```javascript\nconst shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());\n```\n\n**Output:**\n```text\n20\nNaN\n```\n\n**Explanation:**\n*   **`diameter`** is a regular function, so `this` refers to the **calling object** (`shape`). `shape.radius` is 10.\n*   **`perimeter`** is an **arrow function**, so `this` is lexically bound to the **surrounding scope** (window/global), not the `shape` object. On the global object, `radius` is undefined. `2 * PI * undefined` is `NaN`.",
      "difficulty": "Medium",
      "tags": ["this", "arrow-functions"]
    },
    {
      "id": "out-04",
      "q": "What is the output?",
      "a": "```javascript\n+true;\n!'Lydia';\n```\n\n**Output:**\n```text\n1\nfalse\n```\n\n**Explanation:**\n*   The unary plus (`+`) attempts to convert an operand to a number. `true` is converted to `1`.\n*   The exclamation mark (`!`) converts a value to a boolean and negates it. `'Lydia'` is a truthy string. `!truthy` is `false`.",
      "difficulty": "Easy",
      "tags": ["coercion", "operators"]
    },
    {
      "id": "out-05",
      "q": "What is the output?",
      "a": "```javascript\nconst a = {};\nconst b = { key: 'b' };\nconst c = { key: 'c' };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n```\n\n**Output:**\n```text\n456\n```\n\n**Explanation:**\nObject keys are automatically converted to strings. \n*   When you do `a[b]`, `b` converts to `\"[object Object]\"`.\n*   When you do `a[c]`, `c` converts to `\"[object Object]\"`.\n*   So you are essentially doing `a[\"[object Object]\"] = 123` and then overwriting it with `456`.",
      "difficulty": "Medium",
      "tags": ["objects", "coercion"]
    },
    {
      "id": "out-06",
      "q": "What is the output?",
      "a": "```javascript\nfunction foo(a, b = a) {\n    console.log(a + b);\n}\nfoo(1);\nfoo(1, 2);\n```\n\n**Output:**\n```text\n2\n3\n```\n\n**Explanation:**\n*   **`foo(1)`**: `a` is 1. `b` uses the default value `a` (which is 1). `1 + 1 = 2`.\n*   **`foo(1, 2)`**: `a` is 1. `b` is passed as 2 (default is ignored). `1 + 2 = 3`.",
      "difficulty": "Easy",
      "tags": ["functions", "defaults"]
    },
    {
      "id": "out-07",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(0.1 + 0.2 === 0.3);\n```\n\n**Output:**\n```text\nfalse\n```\n\n**Explanation:**\nDue to **floating-point precision** in JavaScript (IEEE 754), `0.1 + 0.2` actually equals `0.30000000000000004`.\nTherefore, it is strictly not equal to `0.3`.",
      "difficulty": "Easy",
      "tags": ["numbers", "precision"]
    },
    {
      "id": "out-08",
      "q": "What is the output?",
      "a": "```javascript\nlet c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);\n```\n\n**Output:**\n```text\nHello\n```\n\n**Explanation:**\nIn JavaScript, objects are passed by **reference**.\nWhen we set `d = c`, `d` holds a reference to the *same* location in memory as `c`.\nChanging a property on `c` affects `d` as well.",
      "difficulty": "Easy",
      "tags": ["objects", "references"]
    },
    {
      "id": "out-09",
      "q": "What is the output?",
      "a": "```javascript\nlet a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n```\n\n**Output:**\n```text\ntrue\nfalse\nfalse\n```\n\n**Explanation:**\n*   `new Number(3)` creates an **object** wrapper around the number (type is `object`).\n*   `a == b`: JavaScript coerces the object to a number value, so `3 == 3` is `true`.\n*   `a === b`: Checks type. `number` !== `object`, so `false`.\n*   `b === c`: `object` !== `number`, so `false`.",
      "difficulty": "Medium",
      "tags": ["coercion", "types"]
    },
    {
      "id": "out-10",
      "q": "What is the output?",
      "a": "```javascript\nfunction getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n```\n\n**Output:**\n```text\nobject\n```\n\n**Explanation:**\nThe rest parameter (`...args`) collects all remaining arguments into an **array**.\nIn JavaScript, arrays are technically objects. So `typeof []` returns `\"object\"`.",
      "difficulty": "Easy",
      "tags": ["arrays", "typeof"]
    },
    {
      "id": "out-11",
      "q": "What is the output?",
      "a": "```javascript\nconst bird = {\n  size: 'small'\n};\n\nconst mouse = {\n  name: 'Mickey',\n  small: true\n};\n\nconsole.log(mouse[bird.size]);\nconsole.log(mouse[bird[\"size\"]]);\nconsole.log(mouse.bird.size);\n```\n\n**Output:**\n```text\ntrue\ntrue\nTypeError\n```\n\n**Explanation:**\n*   `bird.size` is `'small'`. So `mouse[bird.size]` becomes `mouse['small']`, which is `true`.\n*   `bird[\"size\"]` is also `'small'`. Same result.\n*   `mouse.bird` is `undefined`. Trying to access `.size` on `undefined` throws a `TypeError`.",
      "difficulty": "Medium",
      "tags": ["objects", "accessors"]
    },
    {
      "id": "out-12",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(Number(2) === Number(2));\nconsole.log(Boolean(false) === Boolean(false));\nconsole.log(Symbol('foo') === Symbol('foo'));\n```\n\n**Output:**\n```text\ntrue\ntrue\nfalse\n```\n\n**Explanation:**\n*   `Number(2)` returns primitive `2`. `2 === 2` is `true`.\n*   `Boolean(false)` returns primitive `false`. `false === false` is `true`.\n*   **Symbols** are unique identifiers. Every `Symbol()` call creates a completely unique value, even if the description is the same.",
      "difficulty": "Medium",
      "tags": ["symbols", "primitives"]
    },
    {
      "id": "out-13",
      "q": "What is the output?",
      "a": "```javascript\nconst name = 'Lydia';\nconsole.log(name());\n```\n\n**Output:**\n```text\nTypeError\n```\n\n**Explanation:**\n`name` is a string (`'Lydia'`). It is not a function. Trying to invoke a variable that is not a function throws a `TypeError` (e.g., \"name is not a function\").",
      "difficulty": "Easy",
      "tags": ["errors", "types"]
    },
    {
      "id": "out-14",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log('1' + '2');\nconsole.log('1' - '2');\n```\n\n**Output:**\n```text\n\"12\"\n-1\n```\n\n**Explanation:**\n*   `+` operator triggers **concatenation** if one operand is a string. `\"1\" + \"2\"` = `\"12\"`.\n*   `-` operator only works on numbers, so it triggers **numeric conversion**. `1 - 2` = `-1`.",
      "difficulty": "Easy",
      "tags": ["coercion", "operators"]
    },
    {
      "id": "out-15",
      "q": "What is the output?",
      "a": "```javascript\nvar x = 21;\nvar girl = function () {\n  console.log(x);\n  var x = 20;\n};\ngirl();\n```\n\n**Output:**\n```text\nundefined\n```\n\n**Explanation:**\nInside the function `girl`, `var x` is **hoisted** to the top of the function scope. \nIt is effectively:\n```javascript\nvar girl = function () {\n  var x; // undefined\n  console.log(x);\n  x = 20;\n};\n```\nThe global `x` is shadowed by the local `x`.",
      "difficulty": "Medium",
      "tags": ["hoisting", "scope"]
    },
    {
      "id": "out-16",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n```\n\n**Output:**\n```text\nStart\nEnd\nPromise\nTimeout\n```\n\n**Explanation:**\n1.  **Synchronous** code runs first: `'Start'`, then `'End'`.\n2.  **Microtasks** (Promises) have higher priority than **Macrotasks** (setTimeout).\n3.  The Promise callback (`'Promise'`) runs before the setTimeout callback (`'Timeout'`).",
      "difficulty": "Hard",
      "tags": ["event-loop", "async"]
    },
    {
      "id": "out-17",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log([] == ![]);\n```\n\n**Output:**\n```text\ntrue\n```\n\n**Explanation:**\n1.  `![]` evaluates to `false` (arrays are truthy, `!truthy` is `false`).\n2.  Comparison becomes `[] == false`.\n3.  `[]` converts to empty string `\"\"`.\n4.  `false` converts to `0`.\n5.  `\"\"` converts to `0`.\n6.  `0 == 0` is `true`.",
      "difficulty": "Hard",
      "tags": ["coercion", "tricky"]
    },
    {
      "id": "out-18",
      "q": "What is the output?",
      "a": "```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n\nconsole.log(sum(1, '2'));\n```\n\n**Output:**\n```text\n\"12\"\n```\n\n**Explanation:**\nJavaScript performs string concatenation because one argument (`'2'`) is a string. `1` is coerced to `\"1\"`.",
      "difficulty": "Easy",
      "tags": ["coercion"]
    },
    {
      "id": "out-19",
      "q": "What is the output?",
      "a": "```javascript\nconst user = {\n  name: 'Lydia',\n  age: 21\n};\n\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n```\n\n**Output:**\n```text\n{ admin: true, name: \"Lydia\", age: 21 }\n```\n\n**Explanation:**\nThe spread operator `...` copies all enumerable properties from `user` into the new `admin` object.",
      "difficulty": "Easy",
      "tags": ["es6", "objects"]
    },
    {
      "id": "out-20",
      "q": "What is the output?",
      "a": "```javascript\nconst settings = {\n  username: 'lydiahallie',\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, ['level', 'health']);\nconsole.log(data);\n```\n\n**Output:**\n```text\n{\"level\":19,\"health\":90}\n```\n\n**Explanation:**\nThe second argument to `JSON.stringify` is a **replacer**. If it's an array, only the property names included in the array are stringified.",
      "difficulty": "Medium",
      "tags": ["json", "methods"]
    },
    {
      "id": "out-21",
      "q": "What is the output?",
      "a": "```javascript\nlet x = 10;\nlet y = (x++, x + 1);\nconsole.log(x, y);\n```\n\n**Output:**\n```text\n11 12\n```\n\n**Explanation:**\n*   `x++` increments `x` to 11 (post-increment).\n*   The **comma operator** evaluates expressions from left to right and returns the last one.\n*   `x` is now 11. `x + 1` is 12.\n*   So `y` becomes 12, and `x` is 11.",
      "difficulty": "Medium",
      "tags": ["operators"]
    },
    {
      "id": "out-22",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log([1, 2, 3] + [4, 5, 6]);\n```\n\n**Output:**\n```text\n\"1,2,34,5,6\"\n```\n\n**Explanation:**\n*   The `+` operator converts arrays to strings.\n*   `[1, 2, 3].toString()` is `\"1,2,3\"`.\n*   `[4, 5, 6].toString()` is `\"4,5,6\"`.\n*   `\"1,2,3\" + \"4,5,6\"` concatenates them.",
      "difficulty": "Medium",
      "tags": ["coercion", "arrays"]
    },
    {
      "id": "out-23",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(5 > '15' < 5);\nconsole.log(7 < '15' < 7);\nconsole.log(7 < '85' > 5);\n```\n\n**Output:**\n```text\ntrue\ntrue\nfalse\n```\n\n**Explanation:**\n*   `5 > '15'` is `false`. `false < 5` (0 < 5) is `true`.\n*   `7 < '15'` is `true`. `true < 7` (1 < 7) is `true`.\n*   `7 < '85'` is `true`. `true > 5` (1 > 5) is `false`.",
      "difficulty": "Hard",
      "tags": ["operators", "coercion"]
    },
    {
      "id": "out-24",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n}, 1000);\n\nsetTimeout(() => {\n  console.log(3);\n}, 0);\n\nPromise.resolve(1).then(function resolve() {\n  setTimeout(() => {\n    console.log(4);\n  }, 0);\n});\n\nconsole.log(5);\n```\n\n**Output:**\n```text\n1\n5\n3\n4\n2\n```\n\n**Explanation:**\n1.  **Sync**: 1, 5.\n2.  **Microtasks**: Promise callback runs. Schedules Timer 4 (0ms).\n3.  **Macrotasks**: Timer 3 (0ms) was scheduled first, so it runs (Log 3).\n4.  Timer 4 (0ms) runs next (Log 4).\n5.  Timer 2 (1000ms) runs last (Log 2).",
      "difficulty": "Hard",
      "tags": ["event-loop", "async"]
    },
    {
      "id": "out-25",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log([\"a\"] + [\"b\"]);\nconsole.log([] + []);\nconsole.log(![] + []);\n```\n\n**Output:**\n```text\n\"ab\"\n\"\"\n\"false\"\n```\n\n**Explanation:**\n*   Arrays convert to strings: `[\"a\"]` → `\"a\"`, `[\"b\"]` → `\"b\"`.\n*   `[]` → `\"\"`.\n*   `![]` → `false`. `false` + `\"\"` → `\"false\"`.",
      "difficulty": "Medium",
      "tags": ["coercion", "arrays"]
    },
    {
      "id": "out-26",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(3 < 4 < 5);\nconsole.log(3 > 4 > 5);\n```\n\n**Output:**\n```text\ntrue\nfalse\n```\n\n**Explanation:**\n*   `3 < 4` is `true` (1). `1 < 5` is `true`.\n*   `3 > 4` is `false` (0). `0 > 5` is `false`.",
      "difficulty": "Medium",
      "tags": ["operators"]
    },
    {
      "id": "out-27",
      "q": "What is the output?",
      "a": "```javascript\nconst x1 = new Promise((res, req) => {\n  setTimeout(res, 500, \"one\");\n});\n\nconst x2 = new Promise((res, req) => {\n  setTimeout(res, 100, \"two\");\n});\n\nPromise.race([x1, x2]).then((res) => console.log(res));\nPromise.all([x1, x2]).then((res) => console.log(res));\n```\n\n**Output:**\n```text\n\"two\"\n[\"one\", \"two\"]\n```\n\n**Explanation:**\n*   **`race`**: Returns the first promise to settle (`x2` is faster at 100ms).\n*   **`all`**: Waits for ALL promises to resolve and returns an array of results in the original order.",
      "difficulty": "Medium",
      "tags": ["promises", "async"]
    },
    {
      "id": "out-28",
      "q": "What is the output?",
      "a": "```javascript\nconst h1 = { h: \"Thor\" };\nconst h2 = { h: \"Thor\" };\nconst h3 = h2;\nconsole.log(h1 == h2);\nconsole.log(h1 === h2);\nconsole.log(h2 === h3);\n```\n\n**Output:**\n```text\nfalse\nfalse\ntrue\n```\n\n**Explanation:**\nObjects are compared by **reference**, not value. `h1` and `h2` are different objects in memory, even if they look the same. `h3` is a reference to `h2`, so they are equal.",
      "difficulty": "Easy",
      "tags": ["objects", "references"]
    },
    {
      "id": "out-29",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log((1 && 2) || 0 || 3);\nconsole.log(null && undefined);\n```\n\n**Output:**\n```text\n2\nnull\n```\n\n**Explanation:**\n*   `1 && 2` → `2` (last truthy in AND).\n*   `2 || 0` → `2` (first truthy in OR).\n*   `null` is falsy, so `&&` short-circuits and returns `null`.",
      "difficulty": "Medium",
      "tags": ["operators"]
    },
    {
      "id": "out-30",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log('goog' > 'bad');\nconsole.log('Like' < 'like');\n```\n\n**Output:**\n```text\ntrue\ntrue\n```\n\n**Explanation:**\n*   `'g'` (103) > `'b'` (98) is `true`.\n*   `'L'` (76) < `'l'` (108) is `true` (uppercase is smaller in ASCII).",
      "difficulty": "Easy",
      "tags": ["strings", "operators"]
    },
    {
      "id": "out-31",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(\"9\" > \"11\");\nconsole.log(\"9\" > 11);\n```\n\n**Output:**\n```text\ntrue\nfalse\n```\n\n**Explanation:**\n*   **String vs String**: Lexicographical comparison. `'9'` comes after `'1'`, so it is \"greater\".\n*   **String vs Number**: String is converted to number. `9 > 11` is `false`.",
      "difficulty": "Medium",
      "tags": ["coercion", "strings"]
    },
    {
      "id": "out-32",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(Math.round(5.51));\nconsole.log(Math.floor(5.51));\n```\n\n**Output:**\n```text\n6\n5\n```\n\n**Explanation:**\n*   `Math.round` rounds to the nearest integer.\n*   `Math.floor` rounds down.",
      "difficulty": "Easy",
      "tags": ["math"]
    },
    {
      "id": "out-33",
      "q": "What is the output?",
      "a": "```javascript\nfunction foo() {\n  return\n  {\n    msg: \"Hello\"\n  }\n}\nconsole.log(foo());\n```\n\n**Output:**\n```text\nundefined\n```\n\n**Explanation:**\n**Automatic Semicolon Insertion (ASI)** inserts a semicolon after `return` because of the line break. The function returns `undefined`, and the object block is unreachable code.",
      "difficulty": "Medium",
      "tags": ["functions", "asi"]
    },
    {
      "id": "out-34",
      "q": "What is the output?",
      "a": "```javascript\nconst output = (function(x) {\n  delete x;\n  return x;\n})(0);\n\nconsole.log(output);\n```\n\n**Output:**\n```text\n0\n```\n\n**Explanation:**\nThe `delete` operator is used to delete properties from **objects**. It cannot delete local variables or function parameters. The operation returns `false` (or simply fails silently) and `x` remains `0`.",
      "difficulty": "Medium",
      "tags": ["delete", "variables"]
    },
    {
      "id": "out-35",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(['1', '7', '11'].map(parseInt));\n```\n\n**Output:**\n```text\n[1, NaN, 3]\n```\n\n**Explanation:**\n`map` passes 3 arguments to the callback: `(element, index, array)`.\n`parseInt` accepts 2 arguments: `(string, radix)`.\n1. `parseInt('1', 0)`: radix 0 defaults to 10. Result: `1`.\n2. `parseInt('7', 1)`: radix 1 is invalid. Result: `NaN`.\n3. `parseInt('11', 2)`: radix 2 (binary). Result: `3`.",
      "difficulty": "Hard",
      "tags": ["map", "parseInt"]
    },
    {
      "id": "out-36",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(typeof typeof 1);\n```\n\n**Output:**\n```text\n\"string\"\n```\n\n**Explanation:**\n1. `typeof 1` returns `\"number\"`.\n2. `typeof \"number\"` returns `\"string\"` because `\"number\"` is a string.",
      "difficulty": "Easy",
      "tags": ["typeof"]
    },
    {
      "id": "out-37",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(NaN === NaN);\n```\n\n**Output:**\n```text\nfalse\n```\n\n**Explanation:**\n`NaN` (Not-a-Number) is a unique value that is not equal to itself. This is per the IEEE 754 floating-point standard. Use `Number.isNaN()` to check for it.",
      "difficulty": "Easy",
      "tags": ["NaN", "equality"]
    },
    {
      "id": "out-38",
      "q": "What is the output?",
      "a": "```javascript\nconst set = new Set();\nset.add({ a: 1 });\nset.add({ a: 1 });\nconsole.log(set.size);\n```\n\n**Output:**\n```text\n2\n```\n\n**Explanation:**\nObjects in JavaScript are stored by **reference**. The two `{ a: 1 }` objects are distinct in memory, even if their content is identical. `Set` sees them as different values.",
      "difficulty": "Medium",
      "tags": ["sets", "objects"]
    },
    {
      "id": "out-39",
      "q": "What is the output?",
      "a": "```javascript\nconst { name: myName } = { name: 'Lydia' };\nconsole.log(name);\n```\n\n**Output:**\n```text\nReferenceError\n```\n\n**Explanation:**\nWe are using **destructuring with aliasing**. `name` is the source property, and `myName` is the new variable created. `name` is not defined as a variable in the current scope.",
      "difficulty": "Medium",
      "tags": ["destructuring", "es6"]
    },
    {
      "id": "out-40",
      "q": "What is the output?",
      "a": "```javascript\nfunction foo() {\n  try {\n    return 1;\n  } finally {\n    return 2;\n  }\n}\nconsole.log(foo());\n```\n\n**Output:**\n```text\n2\n```\n\n**Explanation:**\nThe `finally` block **always** runs. If it contains a `return` statement, it overrides any return value from the `try` or `catch` blocks.",
      "difficulty": "Medium",
      "tags": ["try-catch", "functions"]
    },
    {
      "id": "out-41",
      "q": "What is the output?",
      "a": "```javascript\n(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n```\n\n**Output:**\n```text\n\"undefined\"\n\"number\"\n```\n\n**Explanation:**\n`let x = (y = 10)` sets `y` to 10 first. Since `y` is not declared with `var`, `let`, or `const`, it becomes a **global variable** (in non-strict mode).\n`x` is declared with `let` inside the function, so it is not accessible outside.",
      "difficulty": "Hard",
      "tags": ["scope", "global"]
    },
    {
      "id": "out-42",
      "q": "What is the output?",
      "a": "```javascript\nclass Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' });\nconsole.log(freddie.colorChange('orange'));\n```\n\n**Output:**\n```text\nTypeError\n```\n\n**Explanation:**\n`colorChange` is a **static** method. Static methods exist on the class itself (`Chameleon`), not on instances (`freddie`). You can call `Chameleon.colorChange()`, but not `freddie.colorChange()`.",
      "difficulty": "Medium",
      "tags": ["classes", "static"]
    },
    {
      "id": "out-43",
      "q": "What is the output?",
      "a": "```javascript\nlet y = 10;\nlet y = 20;\nconsole.log(y);\n```\n\n**Output:**\n```text\nSyntaxError\n```\n\n**Explanation:**\nVariables declared with `let` or `const` **cannot** be redeclared in the same scope. This throws a SyntaxError.",
      "difficulty": "Easy",
      "tags": ["let", "redeclaration"]
    },
    {
      "id": "out-44",
      "q": "What is the output?",
      "a": "```javascript\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());\n```\n\n**Output:**\n```text\nTypeError\n```\n\n**Explanation:**\nYou added `getFullName` to the **constructor function** object, not its prototype. Instances (`member`) do not inherit it. It should be `Person.prototype.getFullName = ...`.",
      "difficulty": "Medium",
      "tags": ["prototypes", "inheritance"]
    },
    {
      "id": "out-45",
      "q": "What is the output?",
      "a": "```javascript\nconst name = new String('Lydia');\nconsole.log(typeof name);\n```\n\n**Output:**\n```text\n\"object\"\n```\n\n**Explanation:**\n`new String()` creates a **String Object** wrapper. It is not a primitive string. `typeof` returns `\"object\"`.",
      "difficulty": "Easy",
      "tags": ["types", "wrappers"]
    },
    {
      "id": "out-46",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(null + 20);\nconsole.log(undefined + 20);\n```\n\n**Output:**\n```text\n20\nNaN\n```\n\n**Explanation:**\n*   `null` converts to `0` in numeric operations. `0 + 20 = 20`.\n*   `undefined` converts to `NaN`. `NaN + 20 = NaN`.",
      "difficulty": "Medium",
      "tags": ["coercion", "math"]
    },
    {
      "id": "out-47",
      "q": "What is the output?",
      "a": "```javascript\nfunction* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\n```\n\n**Output:**\n```text\n10\n20\n```\n\n**Explanation:**\nGenerators return an iterator. calling `.next()` pauses execution at the `yield` keyword and returns the value. The first call returns `10`, the second resumes and returns `20`.",
      "difficulty": "Medium",
      "tags": ["generators", "es6"]
    },
    {
      "id": "out-48",
      "q": "What is the output?",
      "a": "```javascript\nasync function getData() {\n  return await Promise.resolve('I made it!');\n}\n\nconst data = getData();\nconsole.log(data);\n```\n\n**Output:**\n```text\nPromise { <pending> }\n```\n\n**Explanation:**\n`getData` is an `async` function, so it **always** returns a Promise. When `console.log(data)` runs, the promise returned by `getData` is still pending (synchronous execution). To see the value, you must use `.then()` or `await`.",
      "difficulty": "Medium",
      "tags": ["async", "promises"]
    },
    {
      "id": "out-49",
      "q": "What is the output?",
      "a": "```javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers.length);\n```\n\n**Output:**\n```text\n11\n```\n\n**Explanation:**\nAssigning a value to an index higher than the current length expands the array. Indices 3 through 9 are created as **empty slots** (holes). The length becomes `11`.",
      "difficulty": "Easy",
      "tags": ["arrays", "length"]
    },
    {
      "id": "out-50",
      "q": "What is the output?",
      "a": "```javascript\nconst obj = { a: 1, b: 2 };\nObject.setPrototypeOf(obj, { c: 3 });\n\nconsole.log(Object.keys(obj));\n```\n\n**Output:**\n```text\n[\"a\", \"b\"]\n```\n\n**Explanation:**\n`Object.keys()` returns an array of a given object's own enumerable property names, iterated in the same order that a normal loop would. It **does not** include properties from the prototype chain (`c`).",
      "difficulty": "Medium",
      "tags": ["objects", "keys"]
    },
    {
      "id": "out-51",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n}, 1000);\n\nsetTimeout(() => {\n  console.log(3);\n}, 0);\n\nconsole.log(4);\n```\n\n**Output:**\n```text\n1\n4\n3\n2\n```\n\n**Explanation:**\n1.  **Sync**: `1` and `4` are logged immediately.\n2.  **Macrotasks**: `setTimeout(..., 0)` schedules the callback for the next event loop tick (minimum delay).\n3.  `setTimeout(..., 1000)` schedules the callback for at least 1 second later.\n4.  So `3` runs before `2`.",
      "difficulty": "Easy",
      "tags": ["event-loop", "async"]
    },
    {
      "id": "out-52",
      "q": "What is the output?",
      "a": "```javascript\nfor (var i = 0; i < 3; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i);\n    }, 1000);\n  })(i);\n}\n```\n\n**Output:**\n```text\n0\n1\n2\n```\n\n**Explanation:**\nBy using an **IIFE** (Immediately Invoked Function Expression), we create a new **function scope** for each iteration.\nThe value of `i` is passed into the IIFE and captured as a local argument, preserving its value for the callback.",
      "difficulty": "Medium",
      "tags": ["closures", "loops"]
    },
    {
      "id": "out-53",
      "q": "What is the output?",
      "a": "```javascript\nconst array1 = [1, 2, 3];\nconst array2 = [1, 2, 3];\nconst array3 = array2;\n\nconsole.log(array1 === array2);\nconsole.log(array2 === array3);\n```\n\n**Output:**\n```text\nfalse\ntrue\n```\n\n**Explanation:**\n*   `array1` and `array2` are distinct objects in memory. **Arrays are objects** in JavaScript, and objects are compared by reference, not value.\n*   `array3` is assigned the *reference* of `array2`, so they point to the exact same object.",
      "difficulty": "Easy",
      "tags": ["arrays", "references"]
    },
    {
      "id": "out-54",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log('Subscribe' > 'Subg');\nconsole.log('SubScribe' > 'Subg');\n```\n\n**Output:**\n```text\ntrue\nfalse\n```\n\n**Explanation:**\nString comparison is **lexicographical** (character by character).\n*   `'Subscribe'` vs `'Subg'`: 'S', 'u', 'b' match. 's' (code 115) > 'g' (code 103) is `true`.\n*   `'SubScribe'` vs `'Subg'`: 'S', 'u', 'b' match. 'S' (code 83) < 'g' (code 103) is `true`, so comparison `>` is `false`.",
      "difficulty": "Medium",
      "tags": ["strings", "operators"]
    },
    {
      "id": "out-55",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(Math.round(5.51));\nconsole.log(Math.round(-5.51));\n\nconsole.log(Math.floor(5.51));\nconsole.log(Math.floor(-5.51));\n\nconsole.log(Math.ceil(5.51));\nconsole.log(Math.ceil(-5.51));\n```\n\n**Output:**\n```text\n6\n-6\n5\n-6\n6\n-5\n```\n\n**Explanation:**\n*   **`Math.round`**: Rounds to nearest integer. `5.51` -> `6`. `-5.51` -> `-6` (away from zero for .5, but here .51 is clearly closer to -6).\n*   **`Math.floor`**: Rounds **down** (smaller value). `5.51` -> `5`. `-5.51` -> `-6` (since -6 < -5.51).\n*   **`Math.ceil`**: Rounds **up** (larger value). `5.51` -> `6`. `-5.51` -> `-5` (since -5 > -5.51).",
      "difficulty": "Medium",
      "tags": ["math"]
    },
    {
      "id": "out-56",
      "q": "What is the output?",
      "a": "```javascript\nfunction Name() {\n  return\n  {\n    mes: \"JavaScript\"\n  }\n}\nconsole.log(Name());\n\nfunction caName() {\n  return {\n    mes: \"Rowdy Coder\",\n  };\n}\nconsole.log(caName());\n```\n\n**Output:**\n```text\nundefined\n{ mes: \"Rowdy Coder\" }\n```\n\n**Explanation:**\n*   **`Name`**: **Automatic Semicolon Insertion (ASI)** adds a `;` after `return` because of the newline. It returns `undefined`.\n*   **`caName`**: The opening brace `{` is on the same line as `return`, so it returns the object correctly.",
      "difficulty": "Medium",
      "tags": ["functions", "asi"]
    },
    {
      "id": "out-57",
      "q": "What is the output?",
      "a": "```javascript\nvar array = [1, 2, 3, 4, 5];\nconsole.log(array.length);\n\narray.length = 3;\nconsole.log(array.length);\nconsole.log(array);\n\ndelete array[0];\nconsole.log(array);\nconsole.log(array[0]);\nconsole.log(array.length);\n```\n\n**Output:**\n```text\n5\n3\n[1, 2, 3]\n[empty, 2, 3]\nundefined\n3\n```\n\n**Explanation:**\n*   Setting `length` to `3` **truncates** the array, removing elements at index 3 and 4.\n*   `delete array[0]` removes the **value** but keeps the **slot** (it becomes an empty/hole). The length remains `3`.\n*   Accessing a deleted/empty slot returns `undefined`.",
      "difficulty": "Medium",
      "tags": ["arrays", "length", "delete"]
    },
    {
      "id": "out-58",
      "q": "What is the output?",
      "a": "```javascript\nconst arr = [1, 2, 3];\nconst str = \"1,2,3\";\n\nconsole.log(arr == str);\n```\n\n**Output:**\n```text\ntrue\n```\n\n**Explanation:**\nThe `==` operator performs type coercion.\nArrays are coerced to strings via `toString()`, which joins elements with commas.\n`[1, 2, 3].toString()` is `\"1,2,3\"`. So `\"1,2,3\" == \"1,2,3\"` is `true`.",
      "difficulty": "Easy",
      "tags": ["coercion", "arrays"]
    },
    {
      "id": "out-59",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(3 + 3 + \"3\" + 3 + 3);\nconsole.log(1 + 2 + 3 + 4 + 5 + \"6\");\n```\n\n**Output:**\n```text\n\"6333\"\n\"156\"\n```\n\n**Explanation:**\n*   `3 + 3` = `6`. Then `6 + \"3\"` = `\"63\"` (string). Then `\"63\" + 3` = `\"633\"`...\n*   `1 + 2 + 3 + 4 + 5` = `15`. Then `15 + \"6\"` = `\"156\"`.",
      "difficulty": "Easy",
      "tags": ["coercion", "operators"]
    },
    {
      "id": "out-60",
      "q": "What is the output?",
      "a": "```javascript\nvar arr1 = [[1, 2], [2, 4], [4, 8]];\nvar arr2 = [...arr1];\n\narr1[0][1] = \"1\";\narr1[0][0] = \"0\";\narr1[1] = 33;\narr1[0] = 22;\n\nconsole.log(arr1);\nconsole.log(arr2);\n```\n\n**Output:**\n```text\n[ 22, 33, [ 4, 8 ] ]\n[ [ '0', '1' ], [ 2, 4 ], [ 4, 8 ] ]\n```\n\n**Explanation:**\n`arr2` is a **shallow copy**. It holds references to the same inner arrays as `arr1`.\n1.  `arr1[0][1] = \"1\"` modifies the shared array at index 0. `arr2` sees this.\n2.  `arr1[1] = 33` replaces the element in `arr1`. `arr2[1]` retains the original array `[2, 4]`.\n3.  `arr1[0] = 22` replaces the element in `arr1`. `arr2[0]` still points to the modified shared array `['0', '1']`.",
      "difficulty": "Hard",
      "tags": ["arrays", "references", "spread"]
    },
    {
      "id": "out-61",
      "q": "What is the output?",
      "a": "```javascript\nvar testArrowFunc = {\n  name: \"abc\",\n  foo: () => {\n    console.log(this.name);\n  },\n};\ntestArrowFunc.foo();\n\nvar testFunc = {\n  name: \"abc\",\n  foo: function () {\n    console.log(this.name);\n  },\n};\ntestFunc.foo();\n```\n\n**Output:**\n```text\nundefined\nabc\n```\n\n**Explanation:**\n*   **Arrow Function**: `this` is lexically inherited from the outer scope (global/window), where `name` is likely undefined.\n*   **Regular Function**: `this` refers to the **caller object** (`testFunc`), so `this.name` is `'abc'`.",
      "difficulty": "Medium",
      "tags": ["this", "arrow-functions"]
    },
    {
      "id": "out-62",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(0.1 + 0.2 == 0.3);\nconsole.log(0.3 + 0.6 == 0.9);\n```\n\n**Output:**\n```text\nfalse\nfalse\n```\n\n**Explanation:**\nFloating point math is not always precise.\n*   `0.1 + 0.2` = `0.30000000000000004`.\n*   `0.3 + 0.6` = `0.8999999999999999` (not exactly 0.9).",
      "difficulty": "Medium",
      "tags": ["numbers", "precision"]
    },
    {
      "id": "out-63",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(\"first\");\n\nsetTimeout(() => {\n  console.log(\"second\");\n});\n\nqueueMicrotask(() => {\n  console.log(\"third\");\n});\n```\n\n**Output:**\n```text\nfirst\nthird\nsecond\n```\n\n**Explanation:**\n1.  **Sync**: `\"first\"`.\n2.  **Microtask**: `queueMicrotask` queues `\"third\"` (runs before macrotasks).\n3.  **Macrotask**: `setTimeout` queues `\"second\"`.",
      "difficulty": "Medium",
      "tags": ["event-loop", "microtasks"]
    },
    {
      "id": "out-64",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(num);\nvar num;\nnum = 6;\nconsole.log(num);\n\nnumb = 6;\nconsole.log(numb);\nlet numb;\n```\n\n**Output:**\n```text\nundefined\n6\nReferenceError\n```\n\n**Explanation:**\n*   `var num` is **hoisted** and initialized to `undefined`.\n*   `let numb` is **hoisted** but stays in the **Temporal Dead Zone (TDZ)**. Accessing `numb` before its declaration throws a `ReferenceError`.",
      "difficulty": "Medium",
      "tags": ["hoisting", "tdz"]
    },
    {
      "id": "out-65",
      "q": "What is the output?",
      "a": "```javascript\nfunction* myGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst gen = myGenerator();\nconsole.log(gen.next());\n```\n\n**Output:**\n```text\n{ value: 1, done: false }\n```\n\n**Explanation:**\n`gen.next()` returns an object with `value` (the yielded value) and `done` (boolean indicating if generator finished).",
      "difficulty": "Easy",
      "tags": ["generators", "es6"]
    },
    {
      "id": "out-66",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(6 + \"7\");\nconsole.log(true + 5);\nconsole.log(true + \"5\");\n```\n\n**Output:**\n```text\n\"67\"\n6\n\"true5\"\n```\n\n**Explanation:**\n*   `number + string` -> Concatenation (`\"67\"`).\n*   `boolean + number` -> Boolean converts to number (`true`=1). `1 + 5 = 6`.\n*   `boolean + string` -> Boolean converts to string. `\"true\" + \"5\" = \"true5\"`.",
      "difficulty": "Easy",
      "tags": ["coercion", "operators"]
    },
    {
      "id": "out-67",
      "q": "What is the output?",
      "a": "```javascript\nfunction exm() {\n    const name = \"Rowdy Coders\";\n    function inner() {\n      return name;\n    }\n    return inner;\n}\nconst inner_func = exm();\nconsole.log(inner_func);\nconsole.log(inner_func());\n```\n\n**Output:**\n```text\n[Function: inner]\nRowdy Coders\n```\n\n**Explanation:**\n`exm()` returns the `inner` function definition. Calling `inner_func()` executes it, which has access to `name` via **closure**.",
      "difficulty": "Easy",
      "tags": ["closures", "functions"]
    },
    {
      "id": "out-68",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(\"begins\");\n\nsetTimeout(() => {\n  console.log(\"setTimeout 1\");\n  Promise.resolve().then(() => {\n    console.log(\"promise 1\");\n  });\n}, 0);\n\nnew Promise(function (resolve, reject) {\n  console.log(\"promise 2\");\n  setTimeout(function () {\n    console.log(\"setTimeout 2\");\n    resolve(\"resolve 1\");\n  }, 0);\n}).then((res) => {\n  console.log(\"dot then 1\");\n  setTimeout(() => {\n    console.log(res);\n  }, 0);\n});\n```\n\n**Output:**\n```text\nbegins\npromise 2\nsetTimeout 1\npromise 1\nsetTimeout 2\ndot then 1\nresolve 1\n```\n\n**Explanation:**\n1. `begins` (Sync)\n2. `promise 2` (Sync executor)\n3. `setTimeout 1` (Macrotask 1)\n4. `promise 1` (Microtask inside Macrotask 1)\n5. `setTimeout 2` (Macrotask 2)\n6. `dot then 1` (Microtask triggered by resolve in Macrotask 2)\n7. `resolve 1` (Macrotask 3 queued by dot then 1)",
      "difficulty": "Hard",
      "tags": ["event-loop", "promises", "async"]
    },
    {
      "id": "out-69",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nasync function async1() { \n   console.log(\"async1 start\"); \n   await async2(); \n   console.log(\"async1 end\"); \n } \n \n async function async2() { \n   console.log(\"async2\"); \n } \n \n console.log(\"script start\"); \n \n setTimeout(function () { \n   console.log(\"setTimeout\"); \n }, 0); \n \n async1(); \n \n new Promise(function (resolve) { \n   console.log(\"promise1\"); \n   resolve(); \n }).then(function () { \n   console.log(\"promise2\"); \n }); \n \n console.log(\"script end\");\n```\n\n**Output:**\n```text\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n```\n\n**Explanation:**\n1.  **Sync**: `script start`.\n2.  `async1` calls `async2`. `async1 start`, `async2`. `await` suspends `async1`.\n3.  `new Promise`: `promise1`. `resolve()` queues `promise2` microtask.\n4.  **Sync**: `script end`.\n5.  **Microtasks**: \n    *   `async1` resumes -> `async1 end`.\n    *   `promise2` runs.\n6.  **Macrotasks**: `setTimeout` runs.",
      "difficulty": "Hard",
      "tags": ["event-loop", "async-await", "promises"]
    },
    {
      "id": "out-70",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nnew Promise(function (resolve, reject) { \n   setTimeout(function () { \n     resolve(\"Promise\"); \n   }, 1000); \n }).then(function (result) { \n   console.log(result); \n }); \n \n setTimeout(callback, 2000); \n \n // setTimeout() \n setTimeout(function () { \n   console.log(\"setTimeout()\"); \n }, 2000); \n \n // Callbacks \n function callback() { \n   console.log(\"Callback\"); \n } \n \n process.nextTick(function () { \n   console.log(\"process.nextTick()\"); \n });\n```\n\n**Output:**\n```text\nprocess.nextTick()\nPromise\nCallback\nsetTimeout()\n```\n\n**Explanation:**\n1.  **Microtasks**: `process.nextTick` runs immediately after current script (Node.js specific).\n2.  **Timers**: \n    *   1000ms: Promise resolves -> `Promise`.\n    *   2000ms: `callback` -> `Callback`.\n    *   2000ms: Anon func -> `setTimeout()`.",
      "difficulty": "Medium",
      "tags": ["event-loop", "timers", "nodejs"]
    },
    {
      "id": "out-71",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconst obj = { \n     name: \"Billy\", \n     sing: function () { \n       this.age = \"20\"; \n       console.log(\"a\", this); \n       var anotherFunction = function () { \n         this.age = \"30\"; \n         console.log(\"b\", this); \n       }; \n       anotherFunction(); \n     }, \n }; \n obj.sing();\n```\n\n**Output:**\n```text\na { name: 'Billy', sing: [Function: sing], age: '20' }\nb Window (or global)\n```\n\n**Explanation:**\n*   `obj.sing()`: `this` refers to `obj`.\n*   `anotherFunction()`: Called as a standalone function, so `this` defaults to the global object (`Window` in browsers, `global` in Node).",
      "difficulty": "Medium",
      "tags": ["this", "scope"]
    },
    {
      "id": "out-72",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconst a = { \n   count: 0, \n }; \n \n const b = a; \n b.count = a.count++; \n \n console.log(b.count, a.count);\n```\n\n**Output:**\n```text\n0 0\n```\n\n**Explanation:**\n1.  `a.count++` increments `count` to 1 but returns the **old value** (0).\n2.  `b` references the same object as `a`.\n3.  `b.count = 0` sets the property back to 0.\nSo both `b.count` and `a.count` are 0.",
      "difficulty": "Tricky",
      "tags": ["objects", "references", "operators"]
    },
    {
      "id": "out-73",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconst a1 = { \n   count: 0, \n }; \n \n const b1 = a1; \n b1.count = ++a1.count; \n \n console.log(b1.count, a1.count);\n```\n\n**Output:**\n```text\n1 1\n```\n\n**Explanation:**\n1.  `++a1.count` increments `count` to 1 and returns the **new value** (1).\n2.  `b1.count = 1` sets the property to 1.\n3.  `b1` and `a1` are the same object.",
      "difficulty": "Easy",
      "tags": ["objects", "references", "operators"]
    },
    {
      "id": "out-74",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconst s = { \n   hello: \"sri\", \n   34: undefined, \n   1: \"HELLO\", \n   2: \"SSS\", \n }; \n s[\"assign\"] = \"world\"; \n s[-4] = \"mee\"; \n \n console.log(Object.keys(s));\n```\n\n**Output:**\n```text\n['1', '2', '34', 'hello', 'assign', '-4']\n```\n\n**Explanation:**\n`Object.keys` returns keys in this order:\n1.  **Integer-like keys** (sorted ascending): `1`, `2`, `34`.\n2.  **String keys** (insertion order): `hello`, `assign`, `-4`.",
      "difficulty": "Medium",
      "tags": ["objects", "keys"]
    },
    {
      "id": "out-75",
      "q": "Guess the output of the following code?",
      "a": "```javascript\n(function (x) { \n   console.log(\"First IIFE executed\"); \n \n   return (function (y) { \n     console.log(\"Nested IIFE executed\", x); \n })(2); \n })(1);\n```\n\n**Output:**\n```text\nFirst IIFE executed\nNested IIFE executed 1\n```\n\n**Explanation:**\n1.  Outer IIFE runs (`x=1`), logs \"First IIFE executed\".\n2.  Inner IIFE runs (`y=2`). It has access to `x` via closure, so it logs \"Nested IIFE executed 1\".",
      "difficulty": "Easy",
      "tags": ["iife", "scope", "closures"]
    },
    {
      "id": "out-76",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nvar obj = { \n   name: \"sri\", \n   age: 10, \n }  \n \n var obj1 = obj; \n \n obj1.age = \"20\"; \n \n Object.freeze(obj); \n obj1.age = \"30\"; \n console.log(obj.age); \n console.log(obj1.age);\n```\n\n**Output:**\n```text\n20\n20\n```\n\n**Explanation:**\n1.  `obj1` is a reference to `obj`.\n2.  `obj1.age = \"20\"` updates the object.\n3.  `Object.freeze(obj)` makes the object immutable.\n4.  `obj1.age = \"30\"` fails (silently in non-strict mode).\n5.  Both log `20`.",
      "difficulty": "Medium",
      "tags": ["objects", "freeze"]
    },
    {
      "id": "out-77",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconsole.log('start'); \n \n setTimeout(()=>{ \n   console.log('mid'); \n }, 0); \n \n for(let i=0;i<10000;i++){ \n   console.log('thread block'); \n } \n \n console.log('end');\n```\n\n**Output:**\n```text\nstart\nthread block (repeated 10000 times)\nend\nmid\n```\n\n**Explanation:**\n1.  `start` logs.\n2.  `setTimeout` queues callback (macrotask).\n3.  Loop runs synchronously (blocking main thread).\n4.  `end` logs.\n5.  Stack clears, `mid` runs.",
      "difficulty": "Easy",
      "tags": ["event-loop", "blocking"]
    },
    {
      "id": "out-78",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconsole.log(varA); \n console.log(letB); \n \n var varA = \"Rowdy Coders\"; \n let letB = 'Subscribe';\n```\n\n**Output:**\n```text\nundefined\nReferenceError\n```\n\n**Explanation:**\n*   `var` is hoisted and initialized to `undefined`.\n*   `let` is hoisted but stays in **TDZ** until declaration line. Accessing it throws `ReferenceError`.",
      "difficulty": "Easy",
      "tags": ["hoisting", "tdz"]
    },
    {
      "id": "out-79",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nlet value = \"Rowdy Coders\" \n value[1] = \"A\"; \n \n console.log(value); \n console.log(value[0], value[1]);\n```\n\n**Output:**\n```text\nRowdy Coders\nR o\n```\n\n**Explanation:**\nStrings are **immutable** in JavaScript. Index assignment (`value[1] = \"A\"`) is ignored (or throws in strict mode). The string remains unchanged.",
      "difficulty": "Easy",
      "tags": ["strings", "immutability"]
    },
    {
      "id": "out-80",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nfunction tryCatchFinally(){ \n    try { \n     console.log(\"try\"); \n     return; \n    } catch(e){ \n     console.log(\"error\"); \n     return; \n    } finally { \n     console.log(\"finally\"); \n     return; \n   } \n } \n tryCatchFinally();\n```\n\n**Output:**\n```text\ntry\nfinally\n```\n\n**Explanation:**\nThe `finally` block **always** executes, even if there is a `return` statement in the `try` block. The `return` in `try` is paused, `finally` runs, and then the function exits.",
      "difficulty": "Easy",
      "tags": ["try-catch", "finally", "control-flow"]
    },
    {
      "id": "out-81",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nlet flag = true; \n setTimeout(()=>{ \n   flag = false; \n }, 1000) \n \n while(flag){ \n   console.log(\"Does it execute?\") \n }\n```\n\n**Output:**\n```text\nInfinite loop (and likely a browser crash)\n```\n\n**Explanation:**\nThe `while` loop is synchronous and runs on the **Call Stack**. It blocks the stack, so the Event Loop can never push the `setTimeout` callback (which sets `flag = false`) from the Macrotask Queue to the Stack. Thus, `flag` remains `true` forever.",
      "difficulty": "Medium",
      "tags": ["event-loop", "blocking", "loops"]
    },
    {
      "id": "out-82",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nabc(); \n \n function abc(){ \n   console.log(\"1\"); \n } \n \n function abc(){ \n   console.log(\"2\"); \n } \n \n function abc(){ \n   console.log(\"3\"); \n }\n```\n\n**Output:**\n```text\n3\n```\n\n**Explanation:**\nFunction declarations are **hoisted**. When multiple function declarations share the same name, the **last one defined** overwrites the previous ones during the creation phase. So `abc` refers to the function printing \"3\".",
      "difficulty": "Easy",
      "tags": ["hoisting", "functions"]
    },
    {
      "id": "out-83",
      "q": "Guess the output of the following code?",
      "a": "```javascript\nconst person ={ \n   name: \"Rowdy\", \n   age: 1, \n   name: \"Coders\" \n } \n console.log(person);\n```\n\n**Output:**\n```text\n{ name: 'Coders', age: 1 }\n```\n\n**Explanation:**\nIn an object literal, if a key is duplicated, the **last value assigned** takes precedence. The first `name: \"Rowdy\"` is overwritten by `name: \"Coders\"`.",
      "difficulty": "Easy",
      "tags": ["objects", "syntax"]
    },
    {
      "id": "out-84",
      "q": "What is the output?",
      "a": "```javascript\nfunction getInfo(member, year) {\n  member.name = \"Lydia\";\n  year = \"1998\";\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n```\n\n**Output:**\n```text\n{ name: \"Lydia\" } \"1997\"\n```\n\n**Explanation:**\nArguments are passed by **value**. \n*   For objects (`person`), the value is the **reference**. Modifying `member.name` changes the original object.\n*   For primitives (`birthYear`), the value is copied. Reassigning `year` inside the function does not affect `birthYear`.",
      "difficulty": "Easy",
      "tags": ["functions", "references", "scope"]
    },
    {
      "id": "out-85",
      "q": "What is the output?",
      "a": "```javascript\nfunction sayHi() {\n  return (() => 0)();\n}\n\nconsole.log(typeof sayHi());\n```\n\n**Output:**\n```text\n\"number\"\n```\n\n**Explanation:**\nThe `sayHi` function returns the result of an **IIFE** (Immediately Invoked Arrow Function) `(() => 0)()`, which returns `0`.\n`typeof 0` is `\"number\"`.",
      "difficulty": "Medium",
      "tags": ["functions", "typeof"]
    },
    {
      "id": "out-86",
      "q": "What is the output?",
      "a": "```javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n```\n\n**Output:**\n```text\n[1, 2, 3, empty x 7, 11]\n```\n\n**Explanation:**\nAssigning an index larger than the current length creates **empty slots** (holes) in the array between the old end and the new index.",
      "difficulty": "Easy",
      "tags": ["arrays", "sparse-arrays"]
    },
    {
      "id": "out-87",
      "q": "What is the output?",
      "a": "```javascript\n(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n```\n\n**Output:**\n```text\n1\nundefined\n2\n```\n\n**Explanation:**\n1.  Inside `catch(x)`, `x` refers to the **catch block-scoped** variable (the error), not the outer `let x`.\n2.  `x = 1` modifies the inner `x`. Log: `1`.\n3.  `y = 2` modifies the outer `y` (since `y` isn't shadowed).\n4.  Outside catch, `x` is still `undefined` (outer `x` was never assigned). Log: `undefined`.\n5.  `y` is `2`. Log: `2`.",
      "difficulty": "Hard",
      "tags": ["scope", "try-catch", "shadowing"]
    },
    {
      "id": "out-88",
      "q": "What is the output?",
      "a": "```javascript\nconst person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  return `${this.name} is ${age}`;\n}\n\nconsole.log(sayHi.call(person, 21));\nconsole.log(sayHi.bind(person, 21));\n```\n\n**Output:**\n```text\nLydia is 21\n[Function: bound sayHi]\n```\n\n**Explanation:**\n*   `.call()` executes the function **immediately** with the given `this` context.\n*   `.bind()` returns a **new function** with the `this` context bound, but does not execute it immediately.",
      "difficulty": "Medium",
      "tags": ["this", "call-bind-apply"]
    },
    {
      "id": "out-89",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(typeof typeof 1);\n```\n\n**Output:**\n```text\n\"string\"\n```\n\n**Explanation:**\n1.  `typeof 1` returns `\"number\"`.\n2.  `typeof \"number\"` returns `\"string\"`.",
      "difficulty": "Easy",
      "tags": ["typeof", "operators"]
    },
    {
      "id": "out-90",
      "q": "What is the output?",
      "a": "```javascript\nconst numbers = [1, 2, 3];\nnumbers[3] = numbers;\nconsole.log(numbers);\n```\n\n**Output:**\n```text\n[1, 2, 3, [Circular]]\n```\n\n**Explanation:**\nThe array now contains a reference to **itself** at index 3, creating a circular reference. Consoles typically display this as `[Circular]`.",
      "difficulty": "Medium",
      "tags": ["arrays", "references"]
    },
    {
      "id": "out-91",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(!!null);\nconsole.log(!!\"\");\nconsole.log(!!1);\n```\n\n**Output:**\n```text\nfalse\nfalse\ntrue\n```\n\n**Explanation:**\nThe double bang `!!` converts a value to its boolean equivalent.\n*   `null` is falsy -> `false`.\n*   `\"\"` (empty string) is falsy -> `false`.\n*   `1` is truthy -> `true`.",
      "difficulty": "Easy",
      "tags": ["coercion", "booleans"]
    },
    {
      "id": "out-92",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log([...\"Lydia\"]);\n```\n\n**Output:**\n```text\n[\"L\", \"y\", \"d\", \"i\", \"a\"]\n```\n\n**Explanation:**\nStrings are **iterables**. The spread operator `...` maps each character of the string to an element in the new array.",
      "difficulty": "Easy",
      "tags": ["strings", "spread", "es6"]
    },
    {
      "id": "out-93",
      "q": "What is the output?",
      "a": "```javascript\nlet person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n```\n\n**Output:**\n```text\n[{ name: \"Lydia\" }]\n```\n\n**Explanation:**\n`members` array stores a reference to the object `{ name: \"Lydia\" }`.\nSetting `person = null` only changes the `person` variable to point to `null`. It **does not** affect the object itself or the reference stored in the `members` array.",
      "difficulty": "Medium",
      "tags": ["references", "memory"]
    },
    {
      "id": "out-94",
      "q": "What is the output?",
      "a": "```javascript\nconst value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n```\n\n**Output:**\n```text\n20\n20\n20\n40\n```\n\n**Explanation:**\n1.  `multiply()`: Default argument is a **new object** (copy of `value`). `10 * 2 = 20`.\n2.  `multiply()`: Another **new object**. `10 * 2 = 20`.\n3.  `multiply(value)`: Passes reference to `value`. `value.number` becomes `20`. Log: `20`.\n4.  `multiply(value)`: Passes reference to modified `value` (now 20). `20 * 2 = 40`. Log: `40`.",
      "difficulty": "Hard",
      "tags": ["functions", "default-parameters", "references"]
    },
    {
      "id": "out-95",
      "q": "What is the output?",
      "a": "```javascript\n[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\n```\n\n**Output:**\n```text\n1 2\nundefined 3\nundefined 4\n```\n\n**Explanation:**\n1.  First iteration: `x` is initial element `1`, `y` is `2`. `console.log` prints `1 2` and returns `undefined`.\n2.  Second iteration: `x` is `undefined` (result of previous), `y` is `3`. Prints `undefined 3`.\n3.  Third iteration: `x` is `undefined`, `y` is `4`. Prints `undefined 4`.",
      "difficulty": "Medium",
      "tags": ["arrays", "reduce"]
    },
    {
      "id": "out-96",
      "q": "What is the output?",
      "a": "```javascript\nfunction getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n```\n\n**Output:**\n```text\n\"object\"\n```\n\n**Explanation:**\nThe rest parameter `...args` collects arguments into an **array**. Arrays are objects in JavaScript, so `typeof args` is `\"object\"`.",
      "difficulty": "Easy",
      "tags": ["functions", "rest-parameters", "typeof"]
    },
    {
      "id": "out-97",
      "q": "What is the output?",
      "a": "```javascript\nconst set = new Set([1, 1, 2, 3, 4]);\nconsole.log(set);\n```\n\n**Output:**\n```text\nSet { 1, 2, 3, 4 }\n```\n\n**Explanation:**\n`Set` objects store **unique** values. Duplicate `1` is removed.",
      "difficulty": "Easy",
      "tags": ["sets", "es6"]
    },
    {
      "id": "out-98",
      "q": "What is the output?",
      "a": "```javascript\nconst settings = {\n  username: \"lydiahallie\",\n  level: 19,\n  health: 90,\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);\n```\n\n**Output:**\n```text\n\"{\"level\":19,\"health\":90}\"\n```\n\n**Explanation:**\nThe second argument to `JSON.stringify` is the **replacer**. If it's an array, it acts as a whitelist of keys to include in the JSON string.",
      "difficulty": "Medium",
      "tags": ["json", "objects"]
    },
    {
      "id": "out-99",
      "q": "What is the output?",
      "a": "```javascript\nlet x = 10;\nvar y = 20;\n\nconsole.log(window.x);\nconsole.log(window.y);\n```\n\n**Output:**\n```text\nundefined\n20\n```\n\n**Explanation:**\nIn the browser global scope:\n*   `var` declarations add properties to the global object (`window`).\n*   `let` and `const` declarations **do not** add properties to the global object.",
      "difficulty": "Medium",
      "tags": ["scope", "global", "var-let"]
    },
    {
      "id": "out-100",
      "q": "What is the output?",
      "a": "```javascript\nconst obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nconsole.log(obj.hasOwnProperty(\"1\"));\nconsole.log(obj.hasOwnProperty(1));\nconsole.log(set.has(\"1\"));\nconsole.log(set.has(1));\n```\n\n**Output:**\n```text\ntrue\ntrue\nfalse\ntrue\n```\n\n**Explanation:**\n*   **Objects**: Keys are converted to strings. `obj[1]` is the same as `obj[\"1\"]`. So both check for key `\"1\"`.\n*   **Sets**: Values are unique and **type-sensitive**. `set` contains number `1`, not string `\"1\"`.",
      "difficulty": "Medium",
      "tags": ["objects", "sets", "types"]
    },
    {
      "id": "out-101",
      "q": "What is the output?",
      "a": "```javascript\nconst a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n```\n\n**Output:**\n```text\n456\n```\n\n**Explanation:**\nObject keys are converted to strings. \n*   `b` becomes `\"[object Object]\"`.\n*   `c` becomes `\"[object Object]\"`.\nSo `a[\"[object Object]\"]` is set to `123`, then overwritten by `456`.",
      "difficulty": "Medium",
      "tags": ["objects", "keys", "coercion"]
    },
    {
      "id": "out-102",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log(Number(2) === Number(2));\nconsole.log(Boolean(false) === Boolean(false));\nconsole.log(Symbol('foo') === Symbol('foo'));\n```\n\n**Output:**\n```text\ntrue\ntrue\nfalse\n```\n\n**Explanation:**\n*   `Number(2)` returns primitive `2`. `2 === 2` is true.\n*   `Boolean(false)` returns primitive `false`. `false === false` is true.\n*   **Symbols** are always unique. `Symbol('foo')` creates a new unique symbol every time.",
      "difficulty": "Medium",
      "tags": ["symbols", "types", "equality"]
    },
    {
      "id": "out-103",
      "q": "What is the output?",
      "a": "```javascript\nconst name = \"Lydia\";\nconsole.log(!typeof name === \"object\");\nconsole.log(!typeof name === \"string\");\n```\n\n**Output:**\n```text\nfalse\nfalse\n```\n\n**Explanation:**\n**Operator Precedence**: `!` has higher precedence than `===`.\n1.  `typeof name` is `\"string\"`.\n2.  `!\"string\"` is `false` (since non-empty string is truthy).\n3.  `false === \"object\"` is `false`.\n4.  `false === \"string\"` is `false`.",
      "difficulty": "Tricky",
      "tags": ["operators", "precedence", "typeof"]
    },
    {
      "id": "out-104",
      "q": "What is the output?",
      "a": "```javascript\nconst numbers = [1, 2, 3];\nconst [x, y, z] = numbers;\nconsole.log(x, y, z);\n\nconst [a, , c] = numbers;\nconsole.log(a, c);\n```\n\n**Output:**\n```text\n1 2 3\n1 3\n```\n\n**Explanation:**\nDestructuring allows extracting values from arrays.\n*   `[x, y, z]` maps to `1, 2, 3`.\n*   `[a, , c]` skips the second element, mapping `a` to `1` and `c` to `3`.",
      "difficulty": "Easy",
      "tags": ["destructuring", "es6"]
    },
    {
      "id": "out-105",
      "q": "What is the output?",
      "a": "```javascript\nlet count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num => {\n    if (num) count += 1;\n});\n\nconsole.log(count);\n```\n\n**Output:**\n```text\n3\n```\n\n**Explanation:**\n`if (num)` checks if `num` is **truthy**.\n*   `0` is falsy.\n*   `1, 2, 3` are truthy.\nSo count increments 3 times.",
      "difficulty": "Easy",
      "tags": ["arrays", "booleans", "coercion"]
    },
    {
      "id": "out-106",
      "q": "What is the output?",
      "a": "```javascript\nconst person = {\n  name: \"Lydia\",\n  age: 21,\n};\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y);\n}\n```\n\n**Output:**\n```text\nname Lydia\nage 21\n```\n\n**Explanation:**\n`Object.entries(person)` returns `[[\"name\", \"Lydia\"], [\"age\", 21]]`.\nThe loop destructures each entry into `key` (`x`) and `value` (`y`).",
      "difficulty": "Easy",
      "tags": ["objects", "es6", "loops"]
    },
    {
      "id": "out-107",
      "q": "What is the output?",
      "a": "```javascript\nconsole.log('1' - - '1');\nconsole.log('1' + + '1');\n```\n\n**Output:**\n```text\n2\n\"11\"\n```\n\n**Explanation:**\n1.  `'1' - - '1'`: Subtraction `-` coerces strings to numbers. `1 - (-1) = 2`.\n2.  `'1' + + '1'`: Unary `+` coerces `'1'` to number `1`. Then binary `+` sees a string `'1'` on left, so it concatenates. `'1' + 1 = \"11\"`.",
      "difficulty": "Tricky",
      "tags": ["coercion", "operators"]
    },
    {
      "id": "out-108",
      "q": "What is the output?",
      "a": "```javascript\nlet a = 1;\nlet b = 2;\n\n[a, b] = [b, a];\nconsole.log(a, b);\n```\n\n**Output:**\n```text\n2 1\n```\n\n**Explanation:**\nArray destructuring can be used to **swap variables** without a temporary variable.",
      "difficulty": "Easy",
      "tags": ["destructuring", "es6"]
    }
  ]
}